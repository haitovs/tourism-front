<!DOCTYPE html>
<html lang="{{ lang or 'en' }}">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>Expo Site</title>

        <!-- Tailwind / HTMX / Alpine via CDN -->
        <script src="https://cdn.tailwindcss.com"></script>
        <script src="https://unpkg.com/htmx.org@2.0.3"></script>
        <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>

        <!-- CSS: variables first, then components -->
        <link rel="stylesheet" href="{{ url_for('static', path='/css/extra.css') }}" />
        <link rel="stylesheet" href="{{ url_for('static', path='/css/detailbar.css') }}" />
        <link rel="stylesheet" href="{{ url_for('static', path='/css/navpill.css') }}" />
        <link rel="stylesheet" href="{{ url_for('static', path='/css/hero.css') }}" />

        <!-- Fonts -->
        <link
            href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&family=Roboto:wght@400;500;700&display=swap"
            rel="stylesheet"
        />
    </head>
    <body class="bg-[var(--c-bg)] text-[var(--c-text)]">
        {% block content %}{% endblock %}
        <footer class="mt-16 border-t">
            <div class="max-w-[var(--container)] mx-auto px-4 py-8 text-sm text-slate-600">Â© 2025</div>
        </footer>
        <script>
            // Horizontal pager with pages = full-width "slides".
            // Features: mouse wheel horizontal scroll, drag, auto-advance, infinite loop (jump to 1st page).
            function hpager({ intervalMs = 10000, dragFactor = 1.0 } = {}) {
                return {
                    wrap: null, // outer container (has overflow-hidden)
                    track: null, // inner scroller (overflow-x-auto)
                    pageCount: 0,
                    pageIndex: 0,
                    timer: null,
                    dragging: false,
                    lastX: 0,

                    init(wrap, track) {
                        this.wrap = wrap;
                        this.track = track;

                        // Snap to page boundaries on resize
                        const ro = new ResizeObserver(() => this.goTo(this.pageIndex, false));
                        ro.observe(this.wrap);

                        // Auto-advance only if > 1 page
                        if (this.pageCount > 1) {
                            this.timer = setInterval(() => this.next(), intervalMs);
                        }
                    },

                    // Compute current page index from scrollLeft
                    get width() {
                        return this.wrap.clientWidth;
                    },
                    get maxPageIndex() {
                        return Math.max(0, this.pageCount - 1);
                    },

                    goTo(i, smooth = true) {
                        this.pageIndex = i < 0 ? this.maxPageIndex : i > this.maxPageIndex ? 0 : i;
                        this.track.scrollTo({ left: this.pageIndex * this.width, behavior: smooth ? "smooth" : "auto" });
                    },
                    next() {
                        this.goTo(this.pageIndex + 1, true);
                    },
                    prev() {
                        this.goTo(this.pageIndex - 1, true);
                    },

                    // Wheel -> horizontal paging feel
                    onWheel(e) {
                        e.preventDefault();
                        const delta = e.deltaY || e.deltaX || 0;
                        this.track.scrollLeft += delta;
                        // If crossing page thresholds, snap after short delay
                        clearTimeout(this._snapT);
                        this._snapT = setTimeout(() => {
                            const idx = Math.round(this.track.scrollLeft / this.width);
                            if (idx !== this.pageIndex) this.goTo(idx, true);
                        }, 120);
                    },

                    // Drag
                    dragStart(e) {
                        if (this.pageCount <= 1) return;
                        this.dragging = true;
                        this.lastX = (e.touches ? e.touches[0].pageX : e.pageX) || 0;
                        clearInterval(this.timer);
                        e.preventDefault();
                    },
                    dragMove(e) {
                        if (!this.dragging) return;
                        const x = (e.touches ? e.touches[0].pageX : e.pageX) || 0;
                        const dx = (this.lastX - x) * dragFactor;
                        this.track.scrollLeft += dx;
                        this.lastX = x;
                    },
                    dragEnd() {
                        if (!this.dragging) return;
                        this.dragging = false;
                        // Snap to nearest page
                        const idx = Math.round(this.track.scrollLeft / this.width);
                        this.goTo(idx, true);
                        if (this.pageCount > 1) {
                            this.timer = setInterval(() => this.next(), intervalMs);
                        }
                    },
                };
            }
        </script>
    </body>
</html>
